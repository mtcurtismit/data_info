import streamlit as st
import time
import os
import matplotlib.pyplot as plt
import os
from cv2 import VideoCapture, CAP_PROP_FRAME_COUNT, CAP_PROP_FRAME_WIDTH, CAP_PROP_FRAME_HEIGHT, CAP_PROP_FPS
import base64
import numpy as np
import pandas as pd


def homepage():
    '''
    This is the main function, automatically run when the file is downloaded as of now. Once you press the access data button, it starts accessing the specified table and visualizing it.
    '''

    #This does all the things after buttons are pressed
    st.title('Safe City Machine Learning Model')
    p1 = os.path.join(os.getcwd(), 'SCB.jpg')
    ph = st.empty()
    set_background(p1)
    load_data = st.empty()
    save_cont = st.empty()
    df_cont = st.empty()
    file_dir = ''
    savepath = ''
    df_savepath = ''
    with load_data:
        bool3 = st.button('Load data')
    save_bool = save_cont.checkbox('Save plots', key='check1')
    df_bool = df_cont.checkbox('Save DataFrames', key='check2')
    if save_bool:
        savepath = save_cont.text_input('File name', key='ti1')
    if savepath != '':
        save_cont.caption(f'Plots being saved to {savepath}')
    if df_bool:
        df_savepath = df_cont.text_input('File name', key='ti2')
    if df_savepath != '':
        df_cont.caption(f'DataFrames being saved to {df_savepath}')
    if bool3:
        file_dir = load_data.text_input('Type in the directory the files are in')
        if file_dir != '':
            load_data.empty()
            save_cont.empty()
            df_cont.empty()
            data_from_directory(file_dir, load_data, savepath, df_savepath)

    #This is responsible for the screen before clicking any buttons
    with ph.container():
        ph2 = st.empty()
        while file_dir == '':
            t = time.localtime()
            current_time = time.strftime("%H:%M:%S", t)
            with ph2:
                st.write(current_time)
            time.sleep(1)


def get_base64(bin_file):
    #This is for putting the background onto the app, this converts the image into the right form
    with open(bin_file, 'rb') as f:
        data = f.read()
    return base64.b64encode(data).decode()


def set_background(png_file):
    #This is actually puts the processed image as the background
    bin_str = get_base64(png_file)
    page_bg_img = '''
    <style>
    .stApp {
    background-image: url("data:image/png;base64,%s");
    background-size: cover;
    }
    </style>
    ''' % bin_str
    st.markdown(page_bg_img, unsafe_allow_html=True)


def data_from_directory(filepath, plot_container, savepath, df_savepath):
    '''
    GUI function with an input of a file path and an output of statistics about the data. Usable only with subcategories
    '''
    if not os.path.isdir(filepath):
        AssertionError('Inputted filepath is not a directory')
    subcategory_dict = {}
    subcategory_data = {}
    empty = st.empty()
    empty.caption('Finding Video Information')
    plot_container.progress(0/100, text='Videos retrieved')
    for idx, cat in enumerate(os.listdir(filepath)):
        plot_container.progress(idx/len(os.listdir(filepath)), text='Videos retrieved')
        cat_dir = os.path.join(filepath, cat)
        subcategory_dict[cat] = os.listdir(cat_dir)
        for subcategory in os.listdir(cat_dir):
            subcat_dir = os.path.join(cat_dir, subcategory)
            #plot_container.progress(idx/len(os.listdir(filepath))+1/(len(os.listdir(filepath))+len(os.listdir(subcat_dir))), text='Videos retrieved')
            subcategory_data[f'{subcategory}-{cat}'] = []
            for video_file in os.listdir(subcat_dir):
                video_file = os.path.join(subcat_dir, video_file)
                vid = VideoCapture(video_file)

                length = vid.get(CAP_PROP_FRAME_COUNT)
                fps = vid.get(CAP_PROP_FPS)
                width = vid.get(CAP_PROP_FRAME_WIDTH) # float `width`
                height = vid.get(CAP_PROP_FRAME_HEIGHT) # float `height`
                subcategory_data[f'{subcategory}-{cat}'].append((length, fps, (width, height)))
    plot_container.progress(1/1, text='Completed')
    time.sleep(0.25)
    empty.caption('Plotting Data')
    plot_container.empty()
    fig1 = plot_directory_data(plot_container, subcategory_dict, subcategory_data, savepath, df_savepath)
    empty.empty()
    return fig1


def plot_directory_data(plot_container, cat_subcat_mapping, subcat_data, savepath, df_savepath):
    '''
    Input is an st.empty object. Ouputs the graphs onto the local page, and saves into a local file if savepath is specified
    '''

    #Prepares subcategory data
    subcat_lengths = [len(i) for i in list(subcat_data.values())]
    avg_lengths = []
    avg_fps = []
    for subcat in subcat_data:
        lengths = [x[0] for x in list(subcat_data[subcat])]
        fps = [x[1] for x in list(subcat_data[subcat])]
        avg_lengths.append(np.array(lengths))
        avg_fps.append(np.array(fps))

    
    #Prepares category data
    idx = 0
    cat_lengths = []
    cat_fps = []
    for cat in cat_subcat_mapping.keys():
        cat_lengths.append([])
        cat_fps.append([])
        for _ in range(len(cat_subcat_mapping[cat])):
            cat_lengths[-1].extend(list(avg_lengths[idx]))
            cat_fps[-1].extend(avg_fps[idx])
            idx += 1
    
    #Plots categories
    cl2 = [len(x) for x in cat_lengths]
    fig = plt.figure(figsize=(8, 8))
    plt.subplot(1, 2, 1)
    plt.barh(list(cat_subcat_mapping.keys()), cl2)
    #_, xmax, _, _ = plt.axis()
    #text_keys = [x*xmax/len(subcat_data.keys()) for x in range(len(subcat_data.keys()))]
    #for text_key, cl in zip(text_keys, cl2):
    #    plt.text(text_key, cl, cl)
    plt.xlabel('Number of Videos')
    plt.tick_params(axis='y', labelsize=200/(len(list(subcat_data.keys()))))
    plt.xscale('log')
    plt.title('Number of videos in each category')
    plt.subplot(1, 2, 2)
    plt.boxplot(cat_lengths, labels=list(cat_subcat_mapping.keys()))
    plt.boxplot(cat_fps, labels=list(cat_subcat_mapping.keys()))
    plt.ylabel('Number of Frames')
    plt.xticks(rotation=45, ha='right')
    plt.tick_params(axis='x', labelsize=100/(len(list(cat_subcat_mapping.keys()))))
    plt.title('Frame Count Distributions')
    if savepath != '':
        plt.savefig(f'{savepath}_cat')
    st.pyplot(fig)
    get_dataframe(list(cat_subcat_mapping.keys()), cat_lengths, f'{df_savepath}-cat')


    #Plots subcategories
    fig = plt.figure(figsize=(8, 8))
    plt.subplot(1, 2, 1)
    plt.barh(list(subcat_data.keys()), subcat_lengths)
    #_, xmax, _, _ = plt.axis()
    #text_keys = [x*xmax/len(subcat_data.keys()) for x in range(len(subcat_data.keys()))]
    #for text_key, subcat_length in zip(text_keys, subcat_lengths):
    #    plt.text(text_key, subcat_length, subcat_length)
    plt.xlabel('Number of Videos')
    plt.xscale('log')
    plt.tick_params(axis='y', labelsize=200/(len(list(subcat_data.keys()))))
    plt.title('Number of videos in each subcategory')
    plt.subplot(1, 2, 2)
    plt.boxplot(avg_lengths, labels=list(subcat_data.keys()))
    plt.boxplot(avg_fps, labels=list(subcat_data.keys()))
    plt.xticks(rotation=45, ha='right')
    plt.tick_params(axis='x', labelsize=100/(len(list(subcat_data.keys()))))
    plt.ylabel('Number of Frames')
    plt.title('Frame Count Distributions')
    if savepath != '':
        plt.savefig(f'{savepath}_subcat')
    st.pyplot(fig)
    get_dataframe(list(subcat_data.keys()), avg_lengths, f'{df_savepath}-subcat')

def get_dataframe(cat_names, cat_data, savepath):
    # df = pd.DataFrame(columns=cat_names)
    # for name, data in zip(cat_names, cat_data):
    #     for point in data:
    #         df.at[len(df[name]), name] = point
    # st.write(df.describe(include='all'))
    columns = ['Name', 'count', 'mean', 'std', 'min', '25%', '50%', '75%', 'max']
    df = pd.DataFrame(columns=columns)
    for name, data in zip(cat_names, cat_data):
        series = pd.Series(data)
        row = len(df)
        df.at[row, 'Name'] = [name]
        for column in columns[1:]:
            df.at[row, column] = series.describe()[column]
    if savepath[0] != '-':
        with open(savepath, 'a') as f:
            df.to_csv(f)
    totalframe = pd.DataFrame(columns=columns)
    totalframe.at[1, 'Name'] = ['Total']
    for column in columns[1:]:
        if column == 'count':
            totalframe.at[1, column] = df[column].sum()
        if column == 'min':
            totalframe.at[1, column] = df[column].min()
        if column == 'max':
            totalframe.at[1, column] = df[column].max()
        else: totalframe.at[1, column] = df[column].sum()/len(df)
    if savepath[0] != '-':
        with open(savepath, 'a') as f:
            totalframe.to_csv(f)
    st.header('Information in Frame Counts')
    st.write(totalframe)
    st.write(df)
    time_df = df[columns[2:]].apply(lambda x : x/24)
    df.loc[:, columns[2:]] = time_df
    if savepath[0] != '-':
        with open(savepath, 'a') as f:
            df.to_csv(f)
    st.header('Information in Seconds')
    st.write(df)

homepage()
